---
permalink: numpy/meshgrid/
description: A Meshgrid is an ND-coordinate space generated by a set of arrays. Each point on the meshgrid corresponds to a combination of one value from each of the arrays.
name: Meshgrid | plotly
has_thumbnail: true
thumbnail: thumbnail/numpy_array.jpg
layout: user-guide
name: Meshgrid
language: numpy
title: Numpy Meshgrid | plotly
display_as: numpy-array
has_thumbnail: true
page_type: example_index
order: 4
---
{% raw %}
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="New-to-Plotly?">New to Plotly?<a class="anchor-link" href="#New-to-Plotly?">&#182;</a></h4><p>Plotly's Python library is free and open source! <a href="https://plot.ly/python/getting-started/">Get started</a> by downloading the client and <a href="https://plot.ly/python/getting-started/">reading the primer</a>.
<br>You can set up Plotly to work in <a href="https://plot.ly/python/getting-started/#initialization-for-online-plotting">online</a> or <a href="https://plot.ly/python/getting-started/#initialization-for-offline-plotting">offline</a> mode, or in <a href="https://plot.ly/python/getting-started/#start-plotting-online">jupyter notebooks</a>.
<br>We also have a quick-reference <a href="https://images.plot.ly/plotly-documentation/images/python_cheat_sheet.pdf">cheatsheet</a> (new!) to help you get started!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Imports">Imports<a class="anchor-link" href="#Imports">&#182;</a></h3><p>This tutorial imports <a href="https://plot.ly/python/getting-started/">Plotly</a> and <a href="http://www.numpy.org/">Numpy</a>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[1]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="kn">import</span> <span class="nn">plotly.plotly</span> <span class="kn">as</span> <span class="nn">py</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objs</span> <span class="kn">as</span> <span class="nn">go</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</pre></div>

</div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="Linspace/Arange-to-Meshgrid">Linspace/Arange to Meshgrid<a class="anchor-link" href="#Linspace/Arange-to-Meshgrid">&#182;</a></h4><p>The <code>np.meshgrid()</code> function can be used to produce N-D coordinate grids. Let's construct an example to fully understand this.</p>
<p>If you give <code>np.meshgrid()</code> two 1D arrays Array $A$ and Array $B$ such that $A$ is</p>
$$
\begin{align*}
[a_1, a_2, a_3]
\end{align*}
$$<p>and $B$ is</p>
$$
\begin{align*}
[b_1, b_2, b_3]
\end{align*}
$$<p>then running <code>np.meshgrid(A, B)</code> returns a list of two 2D arrays, which look like</p>
$$
\begin{align*}
[[a_1, a_1, a_1], [a_2, a_2, a_2], [a_3, a_3, a_3]]
\end{align*}
$$<p>and</p>
$$
\begin{align*}
[[b_1, b_1, b_1], [b_2, b_2, b_2], [b_3, b_3, b_3]]
\end{align*}
$$<p>for which each array here contains arrays with an array full of the first item, the next filled with all the next item in the original array, etc.</p>
<p>By adding these two arrays together, we can create the 2D array containing, as its elements, every combination of sums between the numbers in the original elements. Arrays such as <code>linspace</code> and <code>arange</code> are typically used to constuct N-D arrays used to plot in 3 dimensions.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[2]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="kn">import</span> <span class="nn">plotly.plotly</span> <span class="kn">as</span> <span class="nn">py</span>
<span class="kn">import</span> <span class="nn">plotly.graph_objs</span> <span class="kn">as</span> <span class="nn">go</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">XX</span><span class="p">,</span> <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">ZZ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">XX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">YY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">XX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">YY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">line_marker</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;#0066FF&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ZZ</span><span class="p">):</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter3d</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;lines&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line_marker</span><span class="p">))</span>

<span class="n">layout</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Layout</span><span class="p">(</span>
    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Wireframe with Meshgrid&#39;</span><span class="p">,</span>
    <span class="n">showlegend</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">lines</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">)</span>
<span class="n">py</span><span class="o">.</span><span class="n">iplot</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;numpy-arange-to-meshgrid&#39;</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt output_prompt">Out[2]:</div>

<div class="output_html rendered_html output_subarea output_execute_result">
<iframe id="igraph" scrolling="no" style="border:none;" seamless="seamless" src="https://plot.ly/~AdamKulidjian/1926.embed" height="525px" width="100%"></iframe>
</div>

</div>

</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In&nbsp;[3]:</div>
<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython2"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">)</span>
</pre></div>

</div>
</div>
</div>

<div class="output_wrapper">
<div class="output">


<div class="output_area"><div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>Help on function meshgrid in module numpy.lib.function_base:

meshgrid(*xi, **kwargs)
    Return coordinate matrices from coordinate vectors.
    
    Make N-D coordinate arrays for vectorized evaluations of
    N-D scalar/vector fields over N-D grids, given
    one-dimensional coordinate arrays x1, x2,..., xn.
    
    .. versionchanged:: 1.9
       1-D and 0-D cases are allowed.
    
    Parameters
    ----------
    x1, x2,..., xn : array_like
        1-D arrays representing the coordinates of a grid.
    indexing : {&#39;xy&#39;, &#39;ij&#39;}, optional
        Cartesian (&#39;xy&#39;, default) or matrix (&#39;ij&#39;) indexing of output.
        See Notes for more details.
    
        .. versionadded:: 1.7.0
    sparse : bool, optional
        If True a sparse grid is returned in order to conserve memory.
        Default is False.
    
        .. versionadded:: 1.7.0
    copy : bool, optional
        If False, a view into the original arrays are returned in order to
        conserve memory.  Default is True.  Please note that
        ``sparse=False, copy=False`` will likely return non-contiguous
        arrays.  Furthermore, more than one element of a broadcast array
        may refer to a single memory location.  If you need to write to the
        arrays, make copies first.
    
        .. versionadded:: 1.7.0
    
    Returns
    -------
    X1, X2,..., XN : ndarray
        For vectors `x1`, `x2`,..., &#39;xn&#39; with lengths ``Ni=len(xi)`` ,
        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing=&#39;ij&#39;
        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing=&#39;xy&#39;
        with the elements of `xi` repeated to fill the matrix along
        the first dimension for `x1`, the second for `x2` and so on.
    
    Notes
    -----
    This function supports both indexing conventions through the indexing
    keyword argument.  Giving the string &#39;ij&#39; returns a meshgrid with
    matrix indexing, while &#39;xy&#39; returns a meshgrid with Cartesian indexing.
    In the 2-D case with inputs of length M and N, the outputs are of shape
    (N, M) for &#39;xy&#39; indexing and (M, N) for &#39;ij&#39; indexing.  In the 3-D case
    with inputs of length M, N and P, outputs are of shape (N, M, P) for
    &#39;xy&#39; indexing and (M, N, P) for &#39;ij&#39; indexing.  The difference is
    illustrated by the following code snippet::
    
        xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;ij&#39;)
        for i in range(nx):
            for j in range(ny):
                # treat xv[i,j], yv[i,j]
    
        xv, yv = meshgrid(x, y, sparse=False, indexing=&#39;xy&#39;)
        for i in range(nx):
            for j in range(ny):
                # treat xv[j,i], yv[j,i]
    
    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.
    
    See Also
    --------
    index_tricks.mgrid : Construct a multi-dimensional &#34;meshgrid&#34;
                     using indexing notation.
    index_tricks.ogrid : Construct an open multi-dimensional &#34;meshgrid&#34;
                     using indexing notation.
    
    Examples
    --------
    &gt;&gt;&gt; nx, ny = (3, 2)
    &gt;&gt;&gt; x = np.linspace(0, 1, nx)
    &gt;&gt;&gt; y = np.linspace(0, 1, ny)
    &gt;&gt;&gt; xv, yv = meshgrid(x, y)
    &gt;&gt;&gt; xv
    array([[ 0. ,  0.5,  1. ],
           [ 0. ,  0.5,  1. ]])
    &gt;&gt;&gt; yv
    array([[ 0.,  0.,  0.],
           [ 1.,  1.,  1.]])
    &gt;&gt;&gt; xv, yv = meshgrid(x, y, sparse=True)  # make sparse output arrays
    &gt;&gt;&gt; xv
    array([[ 0. ,  0.5,  1. ]])
    &gt;&gt;&gt; yv
    array([[ 0.],
           [ 1.]])
    
    `meshgrid` is very useful to evaluate functions on a grid.
    
    &gt;&gt;&gt; x = np.arange(-5, 5, 0.1)
    &gt;&gt;&gt; y = np.arange(-5, 5, 0.1)
    &gt;&gt;&gt; xx, yy = meshgrid(x, y, sparse=True)
    &gt;&gt;&gt; z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)
    &gt;&gt;&gt; h = plt.contourf(x,y,z)

</pre>
</div>
</div>

</div>
</div>

</div>{% endraw %}